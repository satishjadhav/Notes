https://www.youtube.com/playlist?list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6
----------------------------------------------------------------------------------------------------
=>Concurrency Vs Parallelism
	
-Schedular of OS schedules the thread execution.
-Parallelism is about doing lot of things at once.
-Parallelism using java threadpool:
	public static void main(String args[]){
		ExecutorService es = Executors.newFixedThreadPool(nThreads:4);
		es.submit(()->processTx(user1));
		es.submit(()->processTax(user2));
		heavyCalculations();
	}
-Threads
-Threads
	-ExecutorService
	-ForlJoinPool
	-Custom ThreadPools (e.g Web Servers)
-Requires > 1 CPU cores
-Scheduler interleaves threads.
-How much time each thread gets is non deterministic.
-Concurrency is about dealing with lot of things at once.
-Tools to deal with concurrency
	-Locks/synchronized
	-Atomic classes
	-Concurrent data structures (e.g ConcurrentHashMap,BlockingQueue)
	-CompletableFuture
	-CountdownLatch/Phaser/CyclicBarrier/Semaphore etc

=>Java memory Model
-Out of order execution
-Field visibility
	CPU core -> registers -> L1 cache -> L2 cache -> L3 cache -> RAM
-Java memory model is a specification which guarantees visibility of fields (aka happenda before amidst reordering of instructions).
-Volatile -> synchronized -> Lock (ReentrantLock)

=>Using volatile vs AtomicInteger in Java concurrency
-AtomicInterger
	incrementAndGet
	decrementAndGet
	addAndGet(int delta)
	compareAndSet(int expectedValue,int newValue)
-Visibility problem use Volatile
-Compound Operations use Atomic Variables

Type				UseCase
----------------------------------------
Volatile			Flags

AtomicInteger			Counters
AtomicLong			

AtomicReference			Caches (building new cache in background and replacing atomically)
				Used by some internal classes
				Non-blocking algorithms

=>Adder and Accumulator classes in Java 8
public static void main(String []args) throws InterruptedException {

	//AtomicLong counter = new AtomicLong(initialValue:0);

	//LongAdder counter = new LongAdder();

	//LongAccumulator counter = new LongAccumulator((x,y) -> x+y, identity:0s);

	ExecutorService service = Executors.newFixedThreadPool(nThreads: 16);

	for(int i=0; i<100; i++) {
		service.submit(new Task(counter));
	}
	Thread.sleep(100);
	//System.out.println(counter.get());
	System.out.println(counter.sum()); //All thread-local variables added
}
private static class Task implements Runnable {
	private final AtomicLong counter;
	public Tak(AtomicLong counter) {
		this.counter = counter;
	}

	@Override
	public void run(){
		//counter.incementAndGet();
		//counter.increment(); //Thread-local variable incremented
		counter.accumulate(x:1);
	}
}

Accumulator : More generic version of Adder

LongAccumulator counter = new LongAccumulator((x,y) -> x+y, identity:0);
LongAccumulator result = new LongAccumulator((x,y) -> x*y, identity:0);
LongAccumulator min = new LongAccumulator((x,y) -> Math.min(x,y), identity:0);
LongAccumulator max = new LongAccumulator((x,y) -> Math.min(x,y), identity:0);

Best suited for write heavy operations
Order of operations is not deterministic
Accumulation function mat not be applied repeatedly

=>Understanding how ForkJoinPool works

public Result solve(Task t){
	split t into smaller tasks

	for each if these tasks
		solve(t)
	wait for all tasks to complete

	jion all indivisual results

	return results
}

In fork jion framework threads storing all task into its own double ended queue (dequeue)
	Execute Runnable		execute(Runnable)
	Submit Runnable			submit(Runnable)
	Submit Runnable			submit(Callable)


					Call from non-fork-join clients			Call from within fork/jion computations
Arrange async execution			execute(ForkJoinTask)				fork()
Await and obtain result			invoke(ForkJoinTask)				invoke()
Arrange exec and obtain Future		submit(ForkJoinTask)				fork()(ForkJoinTasks are Futures)


Used for Sorting,Matrix multiplication,Best move finder for a game,Tree traversal

SynchronousQueue:
SynchronousQueue is same as BlockingQueue but with size of 1
SQ has no size at all there is a direct handoff between Producer and Consumer thread.
No peek method,no iterate method,perfect for handoffs.

ThradLocal:
Per thread instances for memory efficiency and thread-safety.
Per Thread context
class ThreadSafeFormatter {
	public static ThreadLocal<SimpleDateFormat> dateFormat = new ThreadLocal<SimpleDateFormat>(){
		@Override
		protected SimpleDateFormat initialValue(){
			return new SimpleDateFormat("yyyy-MM-dd");
		}

		@Override
		public SimpleDateFormat get(){
			return super.get();
		}
	}
}

public class UserService {
	public satic void main(String []args){
		//...
	}
	public String birthDate(int userId){
		Date birthDate = birthDateFromDb(userId);
		final SimpleDateFormat df = ThreadSafeFormatter.dateFormatter.get();
		return df.format(birthDate);
	}
}

java-8
class ThreadSafeFormatter {
	public static ThradLocal<SimpleDateFormat> df = ThreadLocal.withInitial(()-> new SimpleDateFormat("yyyy-MM-dd"));
}

public class UserService {
	
	public static void main(String []args){
		//...
	}

	public String birthDate(int userId){
		Date birthDate = birthDateForDB(userId);
		final SimpleDateFormat df = ThradLocalFormatter.df.get();
		return df.format(birthDate);
	}
}
Spring framework uses lot of Context holders:
	LocalContextHolder
	TransactionContextHolder
	RequestContextHolder
	DateTimeContextHolder
	SecurityContextHolder
Thread confinement
Per thread object for perf
per thread context

Phaser Vs CountDownLatch Vs CyclicBarrier:

public static void main(String []args) thorws InterruptedException {

	ExecutorService executor = Executor.newFixedThreadPool(nThreads:4);
	CountDownLatch latch = new CountDownLatch(3);

	executor.submit(new DependentService(latch));
	executor.submit(new DependentService(latch));
	executor.submit(new DependentService(latch));

	latch.wait();

	System.out.println("All dependant services initialized");
}

public static class DependentService impelements Runnable {
	private CountDownLatch latch;

	public DependentService(CountDownLatch latch) {
		this.latch  = latch;
	}

	@Override
	public void run(){
		latch.countDown();
	}
}
Phaser:
	CountDownLatch,CyclicBarrier,Plus more flexibility
public static void main(String []args){

	ExecutorService executor = Executors.newFixedThreadPool(4);

	Phaser phaser = new Phaser(1); //self-register

	executor.submit(new Service(phaser));
	executor.submit(new Service(phaser));

	phaser.bulkRegister(4); //bulk register later
}
public static class Service implements Runnable {
	private Phaser phaser;
	public Service(Phaser phaser) {
		this.phaser = phaser;
	}

	@Override
	public void run(){
		phaser.register();//allow threads to register themselves
		//some operations

		phaser.arrive();
		//other opreations
	}
}


Java Asynchronous Programming
Non-blocking IO and Asyschronous API 
	for(Integer id: employeeIds) {
		CompletableFuture.supplyAsync(() -> fecthEmployee(id)
			.thenApplyAsync(employee -> fetchTaxRate(employee))
			.thenApplyAsync(taxRate -> calculateTax(taxRate))
			.thenAcceptAsync(taxValue -> sendEmail(taxValue)));
	}
Servlets 3.0 Allows more concurrent requests
	@WebServlet(urlPatterns={"/user"}, asyncSupported=true)
	public class UserAsyncService extends HttpServlet {
		
		@Override
		public void doGet(HttpServletRequest request,HttpServletResponse response){
			final AsyncContext context = request.StartAsync();
			context.start(new Runnable() {
				public void run(){
					ServletResponse response = context.getResponse();
					context.complete();
				}
			});
		}
	}

Spring 5.0 Webflux
Java Fibers (lightweight threads)

=>Lock's condition class in java
private Lock lock = new ReentrantLoack();
private Condition conditionMet = lock.newCondition();

public void method1() thorws InterruptedException {
	lock.lock();
	try{
		conditionMet.await();
	}finally {
		lock.unlock();
	}
}

public void method2(){
	lock.lock();
	try{
		conditionMet.signal();
	}finally {
		lock.unloc(); 
	}

}
--------------------------------------------------------
public synchronized void execute(){
	try{
		monitor.wait();
	}catch(InterruptedException e){
		System.err.println("Interrupted");
	}
	//notify thread waiting on the monitor
	monitor.notify();

	//notify all threads
	monitor.notifyAll();
}

lock.lock();

try{
	condition.wait();
}catch(interruptedException e){
	System.err.println("Interrupted");
}

//notify thread waiting on the monitor
condition.signal();

//notify all threads
condition.signalAll();

lock.unlock();

-----------------------------------------
private Lock lock = new ReentrantLock();
private Condition added = lock.newCondition();
private Condition removed = lock.newCondition();

public void produce() throws InterruptedException {

	lock.lock();
	try{
		while(count == MAX_COUNT)
			removed.await();
		
		addData();
		added.signal();
	}finally {
		lock.unlock();
	}
}


public String consume() throws InterruptedException {
	lock.lock();
	try {
		while(count ==0)
			added.await();
		String data = getData();
		removed.signal();
	} finally {
		lock.unlock();
	}
}

=>Semaphore in java concurrency:
public static void main(String []args){
	Semaphore semaphore = new Semaphore(3);

	ExecutorService service = Executors.newFixedThreadPool(50);
	IntStream.of(1000).forEach(i->service.execute(new Task(semaphore)));

	service.shutdown();
	service.awaitTermination(1,TimeUnit.MINUTES);
}
static class Task implements Runnable {

	@Override
	public void run(){
		semaphore.acquireUninterruptibly();
		//semaphore.acquireUninterruptibly(2);

		semaphore.release();
		//semaphore.release(2);
	}
}
Restrict or Manage the use of limited resources	
Method					Meaning
tryAcquire				Try to acquire if no premit avilable do not block.
					Continue doing someting else.
tryAcquire(timeout)			Same as above but with timeout
availablePermits			Return count of permits available
new Semaphore(count,fairness)		FIFO Fairness guarantee for threads waiting the longest.


=>Java ReentrantLock - fairness,tryLock and more
Locks are explicit
Locks allow locking/unlocking in any scopes and in any order
Ability to tryLock and tryLock(timeout)

private static ReentrantLock lock = new ReentrantLock();
private static void accessResource(){
	lock.lock();
	try{
		//access the resource
	} finally {
		lock.unlock();
	}
}

private void accessResource() {
	synchronized(this){	//lock.lock();
	}			//lock.unlock(); 
}
Number of times lock called without calling unlock.

private static void accessResource(){
	lock.lock();
	lock.lock();

	int number = lock.getHoldCount();

	lock.unlock();
	lock.unlock();
}

private static ReentrantLock lock = new ReentrantLock();

private static void accessResource(){
	lock.lock();

	if(someCondition()){
		accessResource();		//recursive call Reentrant
	}
	lock.unlock();
}

Lock fairness:
	ReentrantLock lock = new ReentrantLock(true); //used for lock fairness
	Equal chance for all threads and slower
Unfair Barge-in
	ReentrantLock lockBargeIn = new ReentrantLock();
	ReentrantLock lockBargeIn = new ReentrantLock(false);
	Faster (more throughput) and possible thread starvation
Try lock
private static ReentrantLock lock = new ReentrantLock();
private static void accessResource() throws InterruptedException {
	boolean lockAcquired = lock.tryLock(timeout:5,TimeUnit.SECONDS);
	if(lockAcquired){
		try{
			//access resource
		}finally {
			lock.unlock();
		}
	} else {
		//do alternate thing
	}
}
Method used for debugging :
	isHeldByCurrentThread
	getQueueLength
	newCondition

=>Basic Lock funtion
ReadWriteLock Vs ReentrantLock
ReentrantLock - one thread at a time
ReadWriteLock - one writer thread at a time or multiple reader threads at a time

private ReentrantReadWriteLock lock = new ReentrantReadWriteLcok();

private ReentrantReadWriteLock.ReadLock readLock = lock.readLock();
private ReentrantwriteLock.WriteLock writeLock = lock.writeLock();

private void readResource(){
	readLock.lock();
	//view the resource
	readLock.unlock();
}

private void writeResource(){
	writeLock.lock();
	//update the resource
	writeLock.unlock();
}
ReadLock and WriteLock though are 2 sepaate instances only 1 will be allowed at a time either ReadLock is being used (by n threads) OR WriteLock is being used (by 1 thread) but never both at same time.

=>Exchanger class in java


















































