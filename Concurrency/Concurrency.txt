https://www.youtube.com/playlist?list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6
----------------------------------------------------------------------------------------------------
=>Concurrency Vs Parallelism
	
-Schedular of OS schedules the thread execution.
-Parallelism is about doing lot of things at once.
-Parallelism using java threadpool:
	public static void main(String args[]){
		ExecutorService es = Executors.newFixedThreadPool(nThreads:4);
		es.submit(()->processTx(user1));
		es.submit(()->processTax(user2));
		heavyCalculations();
	}
-Threads
-Threads
	-ExecutorService
	-ForlJoinPool
	-Custom ThreadPools (e.g Web Servers)
-Requires > 1 CPU cores
-Scheduler interleaves threads.
-How much time each thread gets is non deterministic.
-Concurrency is about dealing with lot of things at once.
-Tools to deal with concurrency
	-Locks/synchronized
	-Atomic classes
	-Concurrent data structures (e.g ConcurrentHashMap,BlockingQueue)
	-CompletableFuture
	-CountdownLatch/Phaser/CyclicBarrier/Semaphore etc

=>Java memory Model
-Out of order execution
-Field visibility
	CPU core -> registers -> L1 cache -> L2 cache -> L3 cache -> RAM
-Java memory model is a specification which guarantees visibility of fields (aka happenda before amidst reordering of instructions).
-Volatile -> synchronized -> Lock (ReentrantLock)

=>Using volatile vs AtomicInteger in Java concurrency
-AtomicInterger
	incrementAndGet
	decrementAndGet
	addAndGet(int delta)
	compareAndSet(int expectedValue,int newValue)
-Visibility problem use Volatile
-Compound Operations use Atomic Variables

Type				UseCase
----------------------------------------
Volatile			Flags

AtomicInteger			Counters
AtomicLong			

AtomicReference			Caches (building new cache in background and replacing atomically)
				Used by some internal classes
				Non-blocking algorithms

=>Adder and Accumulator classes in Java 8
public static void main(String []args) throws InterruptedException {

	//AtomicLong counter = new AtomicLong(initialValue:0);

	//LongAdder counter = new LongAdder();

	//LongAccumulator counter = new LongAccumulator((x,y) -> x+y, identity:0s);

	ExecutorService service = Executors.newFixedThreadPool(nThreads: 16);

	for(int i=0; i<100; i++) {
		service.submit(new Task(counter));
	}
	Thread.sleep(100);
	//System.out.println(counter.get());
	System.out.println(counter.sum()); //All thread-local variables added
}
private static class Task implements Runnable {
	private final AtomicLong counter;
	public Tak(AtomicLong counter) {
		this.counter = counter;
	}

	@Override
	public void run(){
		//counter.incementAndGet();
		//counter.increment(); //Thread-local variable incremented
		counter.accumulate(x:1);
	}
}

Accumulator : More generic version of Adder

LongAccumulator counter = new LongAccumulator((x,y) -> x+y, identity:0);
LongAccumulator result = new LongAccumulator((x,y) -> x*y, identity:0);
LongAccumulator min = new LongAccumulator((x,y) -> Math.min(x,y), identity:0);
LongAccumulator max = new LongAccumulator((x,y) -> Math.min(x,y), identity:0);

Best suited for write heavy operations
Order of operations is not deterministic
Accumulation function mat not be applied repeatedly

=>Understanding how ForkJoinPool works

public Result solve(Task t){
	split t into smaller tasks

	for each if these tasks
		solve(t)
	wait for all tasks to complete

	jion all indivisual results

	return results
}

In fork jion framework threads storing all task into its own double ended queue (dequeue)
	Execute Runnable		execute(Runnable)
	Submit Runnable			submit(Runnable)
	Submit Runnable			submit(Callable)


					Call from non-fork-join clients			Call from within fork/jion computations
Arrange async execution			execute(ForkJoinTask)				fork()
Await and obtain result			invoke(ForkJoinTask)				invoke()
Arrange exec and obtain Future		submit(ForkJoinTask)				fork()(ForkJoinTasks are Futures)


Used for Sorting,Matrix multiplication,Best move finder for a game,Tree traversal

SynchronousQueue:
SynchronousQueue is same as BlockingQueue but with size of 1
SQ has no size at all there is a direct handoff between Producer and Consumer thread.
No peek method,no iterate method,perfect for handoffs.

ThradLocal:
Per thread instances for memory efficiency and thread-safety.
Per Thread context
class ThreadSafeFormatter {
	public static ThreadLocal<SimpleDateFormat> dateFormat = new ThreadLocal<SimpleDateFormat>(){
		@Override
		protected SimpleDateFormat initialValue(){
			return new SimpleDateFormat("yyyy-MM-dd");
		}

		@Override
		public SimpleDateFormat get(){
			return super.get();
		}
	}
}

public class UserService {
	public satic void main(String []args){
		//...
	}
	public String birthDate(int userId){
		Date birthDate = birthDateFromDb(userId);
		final SimpleDateFormat df = ThreadSafeFormatter.dateFormatter.get();
		return df.format(birthDate);
	}
}

java-8
class ThreadSafeFormatter {
	public static ThradLocal<SimpleDateFormat> df = ThreadLocal.withInitial(()-> new SimpleDateFormat("yyyy-MM-dd"));
}

public class UserService {
	
	public static void main(String []args){
		//...
	}

	public String birthDate(int userId){
		Date birthDate = birthDateForDB(userId);
		final SimpleDateFormat df = ThradLocalFormatter.df.get();
		return df.format(birthDate);
	}
}
Spring framework uses lot of Context holders:
	LocalContextHolder
	TransactionContextHolder
	RequestContextHolder
	DateTimeContextHolder
	SecurityContextHolder
Thread confinement
Per thread object for perf
per thread context

Phaser Vs CountDownLatch Vs CyclicBarrier:

public static void main(String []args) thorws InterruptedException {

	ExecutorService executor = Executor.newFixedThreadPool(nThreads:4);
	CountDownLatch latch = new CountDownLatch(3);

	executor.submit(new DependentService(latch));
	executor.submit(new DependentService(latch));
	executor.submit(new DependentService(latch));

	latch.wait();

	System.out.println("All dependant services initialized");
}

public static class DependentService impelements Runnable {
	private CountDownLatch latch;

	public DependentService(CountDownLatch latch) {
		this.latch  = latch;
	}

	@Override
	public void run(){
		latch.countDown();
	}
}
Phaser:
	CountDownLatch,CyclicBarrier,Plus more flexibility
public static void main(String []args){

	ExecutorService executor = Executors.newFixedThreadPool(4);

	Phaser phaser = new Phaser(1); //self-register

	executor.submit(new Service(phaser));
	executor.submit(new Service(phaser));

	phaser.bulkRegister(4); //bulk register later
}
public static class Service implements Runnable {
	private Phaser phaser;
	public Service(Phaser phaser) {
		this.phaser = phaser;
	}

	@Override
	public void run(){
		phaser.register();//allow threads to register themselves
		//some operations

		phaser.arrive();
		//other opreations
	}
}


Java Asynchronous Programming
Non-blocking IO and Asyschronous API 
	for(Integer id: employeeIds) {
		CompletableFuture.supplyAsync(() -> fecthEmployee(id)
			.thenApplyAsync(employee -> fetchTaxRate(employee))
			.thenApplyAsync(taxRate -> calculateTax(taxRate))
			.thenAcceptAsync(taxValue -> sendEmail(taxValue)));
	}
Servlets 3.0 Allows more concurrent requests
	@WebServlet(urlPatterns={"/user"}, asyncSupported=true)
	public class UserAsyncService extends HttpServlet {
		
		@Override
		public void doGet(HttpServletRequest request,HttpServletResponse response){
			final AsyncContext context = request.StartAsync();
			context.start(new Runnable() {
				public void run(){
					ServletResponse response = context.getResponse();
					context.complete();
				}
			});
		}
	}

Spring 5.0 Webflux
Java Fibers (lightweight threads)

=>Lock's condition class in java
private Lock lock = new ReentrantLoack();
private Condition conditionMet = lock.newCondition();

public void method1() thorws InterruptedException {
	lock.lock();
	try{
		conditionMet.await();
	}finally {
		lock.unlock();
	}
}

public void method2(){
	lock.lock();
	try{
		conditionMet.signal();
	}finally {
		lock.unloc(); 
	}

}
--------------------------------------------------------
public synchronized void execute(){
	try{
		monitor.wait();
	}catch(InterruptedException e){
		System.err.println("Interrupted");
	}
	//notify thread waiting on the monitor
	monitor.notify();

	//notify all threads
	monitor.notifyAll();
}

lock.lock();

try{
	condition.wait();
}catch(interruptedException e){
	System.err.println("Interrupted");
}

//notify thread waiting on the monitor
condition.signal();

//notify all threads
condition.signalAll();

lock.unlock();

-----------------------------------------
private Lock lock = new ReentrantLock();
private Condition added = lock.newCondition();
private Condition removed = lock.newCondition();

public void produce() throws InterruptedException {

	lock.lock();
	try{
		while(count == MAX_COUNT)
			removed.await();
		
		addData();
		added.signal();
	}finally {
		lock.unlock();
	}
}


public String consume() throws InterruptedException {
	lock.lock();
	try {
		while(count ==0)
			added.await();
		String data = getData();
		removed.signal();
	} finally {
		lock.unlock();
	}
}

































































