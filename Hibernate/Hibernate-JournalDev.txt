https://www.journaldev.com/3633/hibernate-interview-questions-and-answers
---------------------------------------------------------------------------------
-What is Hibernate Framework?
	Obejct-relational mapping or ORM is the programming language technique to map application domain to the relational database tables.Hibernate provides reference implementation of java persistence API, that makes it a great choice as ORM tool with benefits of loose coupling.Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration. 
-Hibernate framework provides support for XML as well as JPA annotations, that makes our code implementation independent.
-Hibernate provides a powerful query language (HQL) that is similar to SQL. However, HQL is fully object-oriented and understands concepts like inheritance, polymorphism and association.
-Hibernate supports lazy initialization using proxy objects and perform actual database queries only when it's required.
-Hibernate supports inheritance,associations and collections.
-JDBC API throws SQLException that is a checked exception, so we need to write a lot of try-catch block code. Most of the times it’s redundant in every JDBC call and used for transaction management. Hibernate wraps JDBC exceptions and throw JDBCException or HibernateException un-checked exception, so we don’t need to write code to handle it. Hibernate built-in transaction management removes the usage of try-catch blocks.
-Hibernate configuration helps us in using JDBC like connection as well as JNDI DataSource for connection pool. This is very important feature in enterprise application and completely missing in JDBC API.
-Name some important interfaces of Hibernate framework?
	1.SesionFactory (org.hibernate.SeesionFactory)
		SessionFactory is an immutable thread-safe cache of compiled mappings for a single database. We need to initialize SessionFactory once and then we can cache and reuse it. SessionFactory instance is used to get the Session objects for database operations.
	2.Session (org.hibernate.Session)
		short-lived object representing a conversation between the application and the persistent store. It wraps JDBC java.sql.Connection and works as a factory for org.hibernate.Transaction. We should open session only when it’s required and close it as soon as we are done using it. Session object is the interface between java application code and hibernate framework and provide methods for CRUD operations.
	3.Transaction (org.hibernate.Transaction)
		Transaction is a single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC or JTA transaction. A org.hibernate.Session might span multiple org.hibernate.Transaction in some cases
-Hibernate configuration file contains database specific configurations and used to initialize SessionFactory. We provide database credentials or JNDI resource information in the hibernate configuration xml file. Some other important parts of hibernate configuration file is Dialect information, so that hibernate knows the database type and mapping file or class details.
-Hibernate mapping file is used to define the entity bean fields and database table column mappings. We know that JPA annotations can be used for mapping but sometimes XML mapping file comes handy when we are using third party classes and we can’t use annotations. 
-Some of the important JPA and hibernate annotations used are:
    javax.persistence.entity: Used with model classes to specify that they are entity beans.
    javax.persistence.Table: Used with entity beans to define the corresponding table name in database.
    javax.persistence.Access: Used to define the access type, either field or property. Default value is field and if you want hibernate to use getter/setter methods then you need to set it to property.
    javax.persistence.Id: Used to define the primary key in the entity bean.
    javax.persistence.EmbeddedId: Used to define composite primary key in the entity bean.
    javax.persistence.Column: Used to define the column name in database table.
    javax.persistence.GeneratedValue: Used to define the strategy to be used for generation of primary key. Used in conjunction with javax.persistence.GenerationType enum.
    javax.persistence.OneToOne: Used to define the one-to-one mapping between two entity beans. We have other similar annotations as OneToMany, ManyToOne and ManyToMany
    org.hibernate.annotations.Cascade: Used to define the cascading between two entity beans, used with mappings. It works in conjunction with org.hibernate.annotations.CascadeType
    javax.persistence.PrimaryKeyJoinColumn: Used to define the property for foreign key. Used with org.hibernate.annotations.GenericGenerator and org.hibernate.annotations.Parameter
-SeesionFactory is the factory class used to get the Session objects.SesionFactory is responsible to read the hibernate configuration parameters and connect to the database and provide Session objects.Usually an application has a single SessionFactory instance and threads servicing client request obtain Session instances from this factory.
The internal state of a SessionFactory is immutable.Once it is created this internal state is set.This internal state includes all of the metadata about Object/Relational Mapping.
Internal state of SessionFactory is immutable, so it’s thread safe. Multiple threads can access it simultaneously to get Session instances. 
-Hibernate Session is the interface between java application layer and hibernate. This is the core interface used to perform database operations. Lifecycle of a session is bound by the beginning and end of a transaction.
Hibernate session object is not thread safe,every thread should get it's own session instance and close it after it's work is finished.
-Hibernate SessionFactory getCurrentSession() method returns the session bound to the context. But for this to work, we need to configure it in hibernate configuration file. Since this session object belongs to the hibernate context, we don’t need to close it. Once the session factory is closed, this session object gets closed.
<property name="hibernate.current_session_context_class">thread</property>
Hibernate SessionFactory openSession() method always opens a new session. We should close this session object once we are done with all the database operations. We should open a new session for each request in multi-threaded environment.
There is another method openStatelessSession() that returns stateless session, for more details with examples please read 
-get() loads the data as soon as it’s called whereas load() returns a proxy object and loads data only when it’s actually required, so load() is better because it support lazy loading.
Since load() throws exception when data is not found, we should use it only when we know data exists. We should use get() when we want to make sure data exists in the database.
-Hibernate first level cache is associated with the Session object. Hibernate first level cache is enabled by default and there is no way to disable it. However hibernate provides methods through which we can delete selected objects from the cache or clear the cache completely.Any object cached in a session will not be visible to other sessions and when the session is closed, all the cached objects will also be lost.
-EHCache is the best choice for utilizing hibernate second level cache. Following steps are required to enable EHCache in hibernate application.
	@Entity
	@Table(name = "ADDRESS")
	@Cache(usage=CacheConcurrencyStrategy.READ_ONLY,region="employee")
	public class Address {
	}
	Hibernate will use the EHCache for second level caching
-An entity bean instance can exist is one of the three states
    Transient: When an object is never persisted or associated with any session, it’s in transient state. Transient instances may be made persistent by calling save(), persist() or saveOrUpdate(). Persistent instances may be made transient by calling delete().
    Persistent: When an object is associated with a unique session, it’s in persistent state. Any instance returned by a get() or load() method is persistent.
    Detached: When an object is previously persistent but not associated with any session, it’s in detached state. Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate(). The state of a transient or detached instance may also be made persistent as a new persistent instance by calling merge().
-What is difference between Hibernate save(), saveOrUpdate() and persist() methods?
	Hibernate save can be used to save entity to database.Problem with save() is that it can be invoked without a transaction and if we have mapping entities, then only the primary objects gets saved causing data inconsistencies.
	Hibernate persist is similar to save with transaction.
	Hibernate saveOrUpdate results into insert or update queries based on the provided data.We can use saveOrUpdate without transaction also but again you will face the issues with mapped objects not getting saved if session is not flushed.
-What will happen if we don’t have no-args constructor in Entity bean?
	Hibernate uses Reflection API to create instance of Entity beans, usually when you call get() or load() methods. The method Class.newInstance() is used for this and it requires no-args constructor. So if you won’t have no-args constructor in entity beans, hibernate will fail to instantiate it and you will get HibernateException.
-What is difference between sorted collection and ordered collection, which one is better?
	When we use Collection API sorting algorithms to sort a collection, it’s called sorted list.
	If we are using Hibernate framework to load collection data from database, we can use it’s Criteria API to use “order by” clause to get ordered list. Below code snippet shows you how to get it.
	List<Employee> empList = session.createCriteria(Employee.class).addOrder(Order.desc("id")).lsit();
	Ordered list is better then sorted list because the actual sorting id done at database level,that is fast and doesn't cause memory issues.
-What are the collection types in Hibernate?
	There are five collection types in hibernate used for one-to-many relationship mappings.
	Bag,Set,List,Array,Map
-How to implement Joins in Hibernate?
	Using associations such as one-to-one, one-to-many etc.
    Using JOIN in the HQL query. There is another form “join fetch” to load associated data simultaneously, no lazy loading.
    We can fire native sql query and use join keyword.
-Why we should not make Entity Class final?
	Hibernate uses proxy classes for lazy loading of data, only when it's needed.This is dobe by extending the entity bean,if the entity bean will be final then lazy loading will not be possible,hence low performance.
-What is HQL and what are it’s benefits?
	Hibernate Query Language (HQL). It’s very similar to SQL except that we use Objects instead of table names, that makes it more close to object oriented programming.
	Hibernate query language is case-insensitive except for java class and variable names.
	The HQL queries are cached but we should avoid it as much as possible, otherwise we will have to take care of associations.
-What is Query Cache in Hibernate?
	Hibernate implements a cache region for queries resultset that integrates closely with the hibernate second level cache.First of all we need to configure below property in hibernate configuration file.
	<property name="hibernate.cache.use_query_cache">true</property>
	And in code we need to use setCacheable(true) method of Query,quick looks like below.
	Query query = session.createQuery("from Employee");
	query.setCacheable(true);
	query.setCacheRegion("ALL_EMP");
-Can we execute native sql query in hibernate?
	Hibernate provide option to execute native SQL queries through the use of SQLQuery object.
	For normal scenarios, it is however not the recommended approach because we loose benefits related to hibernate association and hibernate first level caching.
-What is the benefit of native sql query support in hibernate?
	Native SQL query comes handy when we want to execute database specific queries that are not supported by hibernate API such as query hints or the CONNECT keyword in Oracle Database.
-What is Named SQL Query?
	Hibernate provides Named Query that we cab define at central location and use them anywhere in the code.We can created named queries for both HQL and Native SQL.
	Hibernate Named Queries can be defined in Hibernate mapping files or through the use of JPA annotations @NamedQuery and @NameNativeQuery.
-What are the benefits of Named SQL Query?
	Hibernate Named Query helps us in grouping queries at a central location rather than letting them scattered all over the code.
	Hibernate Named Query syntax is checked when the hibernate session factory is created, thus making the application fail fast in case of any error in the named queries.
	Hibernate Named Query is global, means once defined it can be used throughout the application.
	However one of the major disadvantage of Named query is that it’s hard to debug, because we need to find out the location where it’s defined.
-What is the benefit of Hibernate Criteria API?
	Hibernate provides Criteria API that is more object oriented for querying the database and getting results. We can’t use Criteria to run update or delete queries or any DDL statements. It’s only used to fetch the results from the database using more object oriented approach.
	Criteria API provides Projection that we can use for aggregate functions such as sum(), min(), max() etc.
    Criteria API can be used with ProjectionList to fetch selected columns only.
    Criteria API can be used for join queries by joining multiple tables, useful methods are createAlias(), setFetchMode() and setProjection()
    Criteria API can be used for fetching results with conditions, useful methods are add() where we can add Restrictions.
    Criteria API provides addOrder() method that we can use for ordering the results.
-How to log hibernate generated sql queries in log files?
	We can set below property for hibernate configuration to log SQL queries
		<property name="hibernate.show_sql">true</property>
-What is Hibernate Proxy and how it helps in lazy loading?
	Hibernate uses proxy object to support lazy loading. Basically when you load data from tables, hibernate doesn’t load all the mapped objects. As soon as you reference a child or lookup object via getter methods, if the linked entity is not in the session cache, then the proxy code will go to the database and load the linked object. It uses javassist to effectively and dynamically generate sub-classed implementations of your entity objects.
-How to implement relationships in hibernate?
	We can easily implement one-to-one, one-to-many and many-to-many relationships in hibernate. It can be done using JPA annotations as well as XML based configurations.
    Hibernate One to One Mapping
    Hibernate One to Many Mapping
    Hibernate Many to Many Mapping
-How transaction management works in Hibernate?
	after getting the session from SessionFactory, we can call session beginTransaction() to start the transaction. This method returns the Transaction reference that we can use later on to either commit or rollback the transaction.
	Overall hibernate transaction management is better than JDBC transaction management because we don’t need to rely on exceptions for rollback. Any exception thrown by session methods automatically rollback the transaction. 
-What is cascading and what are different types of cascading?
	When we have relationship between entities then we need to define how the different operations will affect the other entity.
	
	import org.hibernate.annotations.Cascade;
	
	@Entity
	@Table(name="EMPLOYEE")
	public class Employee {
		@OneToOne(mappedBy = "employee")
		@Cascade(value="org.hibernate.annotations.CascadeType.ALL")
		private Address address;
	}
    None: No Cascading, it’s not a type but when we don’t define any cascading then no operations in parent affects the child.
    ALL: Cascades save, delete, update, evict, lock, replicate, merge, persist. Basically everything
    SAVE_UPDATE: Cascades save and update, available only in hibernate.
    DELETE: Corresponds to the Hibernate native DELETE action, only in hibernate.
    DETATCH, MERGE, PERSIST, REFRESH and REMOVE – for similar operations
    LOCK: Corresponds to the Hibernate native LOCK action.
    REPLICATE: Corresponds to the Hibernate native REPLICATE action.
-How to use application server JNDI DataSource with Hibernate framework?
	For web applications, it's always best to allow servlet container to manage the connection pool.That's why we define JNDI resource for DataSource and we can use it in the application.
	<property name="hibernate.connection.datasource">java:comp/env/jdbc/MyLocalDB</property>
-How to integrate Hibernate and Spring Framework?
	If you are using Hibernate 3 you need to configure
	org.springframework.orm.hibernate3.LocalSessionFactoryBean
	or
	org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean
	in Spring Bean configuration file.
	For Hibernate 4, there is single class
	org.springfremework.orm.hibernate4.LocalSessionFactoryBean
	that should be configured.
	Note that we don't need to use Hibernate Transaction Management,we can leave it to Spring declarative transaction management using @Transactional annotation.
-What is HibernateTemplate class?
	When Spring and Hibernate integration started, Spring ORM provided two helper classes – HibernateDaoSupport and HibernateTemplate. The reason to use them was to get the Session from Hibernate and get the benefit of Spring transaction management. However from Hibernate 3.0.1, we can use SessionFactory getCurrentSession() method to get the current session and use it to get the spring transaction management benefits.
	One other benefit of HibernateTemplate was exception translation but that can be achieved easily by using @Repository annotation with service classes.
-How to integrate Hibernate with Servlet or Struts2 web applications?
	Hibernate integration with Servlet or Struts2 needs to be done using ServletContextListener
-Which design patterns are used in Hibernate framework?
	Domain Model Pattern – An object model of the domain that incorporates both behavior and data.
    Data Mapper – A layer of Mappers that moves data between objects and a database while keeping them independent of each other and the mapper itself.
    Proxy Pattern for lazy loading
    Factory pattern in SessionFactory
-What are best practices to follow with Hibernate framework?
	Always check the primary key field access, if it’s generated at the database layer then you should not have a setter for this.
    By default hibernate set the field values directly, without using setters. So if you want hibernate to use setters, then make sure proper access is defined as @Access(value=AccessType.PROPERTY).
    If access type is property, make sure annotations are used with getter methods and not setter methods. Avoid mixing of using annotations on both filed and getter methods.
    Use native sql query only when it can’t be done using HQL, such as using database specific feature.
    If you have to sort the collection, use ordered list rather than sorting it using Collection API.
    Use named queries wisely, keep it at a single place for easy debugging. Use them for commonly used queries only. For entity specific query, you can keep them in the entity bean itself.
    For web applications, always try to use JNDI DataSource rather than configuring to create connection in hibernate.
    Avoid Many-to-Many relationships, it can be easily implemented using bidirectional One-to-Many and Many-to-One relationships.
    For collections, try to use Lists, maps and sets. Avoid array because you don’t get benefit of lazy loading.
    Do not treat exceptions as recoverable, roll back the Transaction and close the Session. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state.
    Prefer DAO pattern for exposing the different methods that can be used with entity bean
    Prefer lazy fetching for associations.
-What is Hibernate Validator Framework?
	Data validation is integral part of any application. You will find data validation at presentation layer with the use of Javascript, then at the server side code before processing it. Also data validation occurs before persisting it, to make sure it follows the correct format.
	Validation is a cross cutting task, so we should try to keep it apart from our business logic. That’s why JSR303 and JSR349 provides specification for validating a bean by using annotations. Hibernate Validator provides the reference implementation of both these bean validation specs. Read more at Hibernate Validation Example. 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-